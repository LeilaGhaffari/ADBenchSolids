#ifndef TAPENADE_H
#define TAPENADE_H

#include "utils.h"

#define NUM_COMPONENTS_STORED_TAPENADE 15

typedef struct {
  double lambda;
  double mu;
  double *stored;
} TapenadeContext;

void init_tapenade(void *ctx);
void free_tapenade(void *ctx);
void f_tapenade(void *ctx, const double dXdx_initial[3][3],
                const double dudX[3][3], double f1[3][3]);
void df_tapenade(void *ctx, const double ddudX[3][3], double df1[3][3]);

// -----------------------------------------------------------
/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.16 (develop) - 27 Oct 2024 18:07
*/
// -----------------------------------------------------------
static inline void MatDetAM1Symmetric_t(const double A_sym[6], double *det) {
  *det = A_sym[0] * (A_sym[1] * A_sym[2] - A_sym[3] * A_sym[3]) +
         A_sym[5] * (A_sym[3] * A_sym[4] - A_sym[5] * A_sym[2]) +
         A_sym[4] * (A_sym[5] * A_sym[3] - A_sym[4] * A_sym[1]) +
         A_sym[0] + A_sym[1] + A_sym[2] +
         A_sym[0] * A_sym[1] + A_sym[0] * A_sym[2] + A_sym[1] * A_sym[2] -
         A_sym[5] * A_sym[5] - A_sym[4] * A_sym[4] - A_sym[3] * A_sym[3];
};

static inline void MatTraceSymmetric_t(const double A_sym[6], double *trace) {
  *trace = A_sym[0] + A_sym[1] + A_sym[2];
};

static inline void MatDetAM1Symmetric_t_b(const double A_sym[6], double A_symb[6], double *det
        , double *detb) {
    double tempb;
    double tempb0;
    double tempb1;
    int ii1;
    tempb1 = A_sym[4]*(*detb);
    tempb0 = A_sym[5]*(*detb);
    for (ii1 = 0; ii1 < 6; ++ii1)
        A_symb[ii1] = 0.0;
    A_symb[0] = A_symb[0] + (A_sym[1]*A_sym[2]-A_sym[3]*A_sym[3]+A_sym[1]+
        A_sym[2]+1.0)*(*detb);
    tempb = A_sym[0]*(*detb);
    A_symb[5] = A_symb[5] + (A_sym[3]*A_sym[4]-A_sym[5]*A_sym[2]-2*A_sym[5])*(
        *detb) + A_sym[3]*tempb1 - A_sym[2]*tempb0;
    A_symb[4] = A_symb[4] + (A_sym[5]*A_sym[3]-A_sym[4]*A_sym[1]-2*A_sym[4])*(
        *detb) + A_sym[3]*tempb0 - A_sym[1]*tempb1;
    A_symb[1] = A_symb[1] + (A_sym[0]+A_sym[2]+1.0)*(*detb) + A_sym[2]*tempb -
        A_sym[4]*tempb1;
    A_symb[2] = A_symb[2] + (A_sym[0]+A_sym[1]+1.0)*(*detb) + A_sym[1]*tempb -
        A_sym[5]*tempb0;
    A_symb[3] = A_symb[3] + A_sym[5]*tempb1 - 2*A_sym[3]*(*detb) + A_sym[4]*
        tempb0 - 2*A_sym[3]*tempb;
}

static inline void MatDetAM1Symmetric_t_nodiff(const double A_sym[6], double *det) {
    *det = A_sym[0]*(A_sym[1]*A_sym[2]-A_sym[3]*A_sym[3]) + A_sym[5]*(A_sym[3]
        *A_sym[4]-A_sym[5]*A_sym[2]) + A_sym[4]*(A_sym[5]*A_sym[3]-A_sym[4]*
        A_sym[1]) + A_sym[0] + A_sym[1] + A_sym[2] + A_sym[0]*A_sym[1] + A_sym
        [0]*A_sym[2] + A_sym[1]*A_sym[2] - A_sym[5]*A_sym[5] - A_sym[4]*A_sym[
        4] - A_sym[3]*A_sym[3];
}

static inline void MatTraceSymmetric_t_b(const double A_sym[6], double A_symb[6], double *trace, double *traceb) {
    A_symb[0] = A_symb[0] + *traceb;
    A_symb[1] = A_symb[1] + *traceb;
    A_symb[2] = A_symb[2] + *traceb;
}

static inline void MatTraceSymmetric_t_nodiff(const double A_sym[6], double *trace) {
    *trace = A_sym[0] + A_sym[1] + A_sym[2];
}

static inline void tau_symmetric(double e_sym[6], double e_symb[6], double tau_sym[6], const double lambda,
        double *lambdab, const double mu, double *mub, double *energyb) {
    double e2_sym[6];
    double e2_symb[6];
    for (int i = 0; i < 6; ++i)
        e2_sym[i] = 2*e_sym[i];
    double detbm1;
    double detbm1b;
    MatDetAM1Symmetric_t_nodiff(e2_sym, &detbm1);
    double J;
    double Jb;
    J = sqrt(detbm1 + 1);
    double logJ = log(detbm1+1)/2.;
    double logJb = 0.0;
    double trace_e;
    double trace_eb;
    double TOL = 1E-8;
    MatTraceSymmetric_t_nodiff(e_sym, &trace_e);
    *lambdab = *lambdab + ((J*J-1)/4-logJ/2)*(*energyb);
    Jb = 2*J*lambda*(*energyb)/4;
    logJb = -((lambda/2+mu)*(*energyb));
    *mub = *mub + (trace_e-logJ)*(*energyb);
    trace_eb = mu*(*energyb);
    *energyb = 0.0;
    MatTraceSymmetric_t_b(e_sym, e_symb, &trace_e, &trace_eb);
    detbm1b = (fabs(detbm1 + 1) < TOL ? logJb/((detbm1+1)*2.) : logJb/((detbm1+1)*
        2.) + Jb/(2.0*sqrt(detbm1+1)));
    MatDetAM1Symmetric_t_b(e2_sym, e2_symb, &detbm1, &detbm1b);
    for (int i = 5; i > -1; --i) {
        e_symb[i] = e_symb[i] + 2*e2_symb[i];
        e2_symb[i] = 0.0;
    }

    for (int i = 3; i < 6; i++) e_symb[i] /= 2.;

    // b = 2 e + I
    double b_sym[6];
    for (int j = 0; j < 6; j++) b_sym[j] = 2 * e_sym[j] + (j < 3);

    // tau = (dPsi / de) b
    double dPsi[3][3], b[3][3], tau[3][3];
    SymmetricMatUnpack(e_symb, dPsi);
    SymmetricMatUnpack(b_sym, b);
    MatMatMult(1., dPsi, b, tau);
    SymmetricMatPack(tau, tau_sym);
}

/*
  Differentiation of SymmetricMatUnpack in forward (tangent) mode:
   variations   of useful results: full[0:3-1][0:3-1]
   with respect to varying inputs: sym[0:6-1]
   Plus diff mem management of: full:in full[0:3-1]:in sym:in
*/
static inline void SymmetricMatUnpack_d(const double sym[6], const double symd[6], double
        full[3][3], double fulld[3][3]) {
    int ii2;
    int ii1;
    for (ii1 = 0; ii1 < 3; ++ii1)
        for (ii2 = 0; ii2 < 3; ++ii2)
            fulld[ii1][ii2] = 0.0;
    fulld[0][0] = symd[0];
    full[0][0] = sym[0];
    fulld[0][1] = symd[5];
    full[0][1] = sym[5];
    fulld[0][2] = symd[4];
    full[0][2] = sym[4];
    fulld[1][0] = symd[5];
    full[1][0] = sym[5];
    fulld[1][1] = symd[1];
    full[1][1] = sym[1];
    fulld[1][2] = symd[3];
    full[1][2] = sym[3];
    fulld[2][0] = symd[4];
    full[2][0] = sym[4];
    fulld[2][1] = symd[3];
    full[2][1] = sym[3];
    fulld[2][2] = symd[2];
    full[2][2] = sym[2];
}

/*
  Differentiation of MatMatMult in forward (tangent) mode:
   variations   of useful results: C[0:3-1][0:3-1]
   with respect to varying inputs: A[0:3-1][0:3-1] B[0:3-1][0:3-1]
   Plus diff mem management of: A:in A[0:3-1]:in B:in B[0:3-1]:in
                C:in C[0:3-1]:in
*/
static inline void MatMatMult_d(double alpha, double const A[3][3], double const Ad[3][3],
        double const B[3][3], double const Bd[3][3], double C[3][3], double Cd
        [3][3]) {
    int ii2;
    int ii1;
    for (ii1 = 0; ii1 < 3; ++ii1)
        for (ii2 = 0; ii2 < 3; ++ii2)
            Cd[ii1][ii2] = 0.0;
    for (int j = 0; j < 3; ++j)
        for (int k = 0; k < 3; ++k) {
            Cd[j][k] = 0.0;
            C[j][k] = 0;
            for (int m = 0; m < 3; ++m) {
                Cd[j][k] = Cd[j][k] + alpha*(B[m][k]*Ad[j][m]+A[j][m]*Bd[m][k]
                    );
                C[j][k] += alpha*A[j][m]*B[m][k];
            }
        }
}

/*
  Differentiation of SymmetricMatPack in forward (tangent) mode:
   variations   of useful results: sym[0:6-1]
   with respect to varying inputs: sym[0:6-1] full[0:3-1][0:3-1]
   Plus diff mem management of: sym:in full:in full[0:3-1]:in
*/
static inline void SymmetricMatPack_d(double const full[3][3], double const fulld[3][3],
        double sym[6], double symd[6]) {
    symd[0] = fulld[0][0];
    sym[0] = full[0][0];
    symd[1] = fulld[1][1];
    sym[1] = full[1][1];
    symd[2] = fulld[2][2];
    sym[2] = full[2][2];
    symd[3] = fulld[1][2];
    sym[3] = full[1][2];
    symd[4] = fulld[0][2];
    sym[4] = full[0][2];
    symd[5] = fulld[0][1];
    sym[5] = full[0][1];
}

/*
  Differentiation of MatDetAM1Symmetric_t_b in forward (tangent) mode:
   variations   of useful results: A_symb[0:6-1]
   with respect to varying inputs: *detb A_sym[0:6-1]
   Plus diff mem management of: A_symb:in detb:in A_sym:in


  Differentiation of MatDetAM1Symmetric_t in reverse (adjoint) mode:
   gradient     of useful results: *det
   with respect to varying inputs: A_sym[0:6-1]
   Plus diff mem management of: det:in A_sym:in
*/
static inline void MatDetAM1Symmetric_t_b_d(const double A_sym[6], const double A_symd[6],
        double A_symb[6], double A_symbd[6], double *det, double *detb, double
        *detbd) {
    double tempb;
    double tempbd;
    double tempb0;
    double tempb0d;
    double tempb1;
    double tempb1d;
    int ii1;
    int ii10;
    double temp;
    tempb1d = (*detb)*A_symd[4] + A_sym[4]*(*detbd);
    tempb1 = A_sym[4]*(*detb);
    tempb0d = (*detb)*A_symd[5] + A_sym[5]*(*detbd);
    tempb0 = A_sym[5]*(*detb);
    for (ii1 = 0; ii1 < 6; ++ii1) {
        A_symbd[ii1] = 0.0;
        A_symb[ii1] = 0.0;
    }
    for (ii10 = 0; ii10 < 6; ++ii10)
        A_symbd[ii10] = 0.0;
    temp = A_sym[1]*A_sym[2] - A_sym[3]*A_sym[3] + A_sym[1] + A_sym[2] + 1.0;
    A_symbd[0] = (*detb)*((A_sym[2]+1.0)*A_symd[1]+(A_sym[1]+1.0)*A_symd[2]-2*
        A_sym[3]*A_symd[3]) + temp*(*detbd);
    A_symb[0] = A_symb[0] + temp*(*detb);
    tempbd = (*detb)*A_symd[0] + A_sym[0]*(*detbd);
    tempb = A_sym[0]*(*detb);
    temp = A_sym[3]*A_sym[4] - A_sym[5]*A_sym[2] - 2*A_sym[5];
    A_symbd[5] = A_symbd[5] + (*detb)*(A_sym[4]*A_symd[3]+A_sym[3]*A_symd[4]-(
        A_sym[2]+2)*A_symd[5]-A_sym[5]*A_symd[2]) + temp*(*detbd) + tempb1*
        A_symd[3] + A_sym[3]*tempb1d - tempb0*A_symd[2] - A_sym[2]*tempb0d;
    A_symb[5] = A_symb[5] + temp*(*detb) + A_sym[3]*tempb1 - A_sym[2]*tempb0;
    temp = A_sym[5]*A_sym[3] - A_sym[4]*A_sym[1] - 2*A_sym[4];
    A_symbd[4] = A_symbd[4] + (*detb)*(A_sym[3]*A_symd[5]+A_sym[5]*A_symd[3]-(
        A_sym[1]+2)*A_symd[4]-A_sym[4]*A_symd[1]) + temp*(*detbd) + tempb0*
        A_symd[3] + A_sym[3]*tempb0d - tempb1*A_symd[1] - A_sym[1]*tempb1d;
    A_symb[4] = A_symb[4] + temp*(*detb) + A_sym[3]*tempb0 - A_sym[1]*tempb1;
    A_symbd[1] = A_symbd[1] + (*detb)*(A_symd[0]+A_symd[2]) + (A_sym[0]+A_sym[
        2]+1.0)*(*detbd) + tempb*A_symd[2] + A_sym[2]*tempbd - tempb1*A_symd[4
        ] - A_sym[4]*tempb1d;
    A_symb[1] = A_symb[1] + (A_sym[0]+A_sym[2]+1.0)*(*detb) + A_sym[2]*tempb -
        A_sym[4]*tempb1;
    A_symbd[2] = A_symbd[2] + (*detb)*(A_symd[0]+A_symd[1]) + (A_sym[0]+A_sym[
        1]+1.0)*(*detbd) + tempb*A_symd[1] + A_sym[1]*tempbd - tempb0*A_symd[5
        ] - A_sym[5]*tempb0d;
    A_symb[2] = A_symb[2] + (A_sym[0]+A_sym[1]+1.0)*(*detb) + A_sym[1]*tempb -
        A_sym[5]*tempb0;
    A_symbd[3] = A_symbd[3] + tempb1*A_symd[5] + A_sym[5]*tempb1d - (2*(*detb)
        +2*tempb)*A_symd[3] - 2*A_sym[3]*(*detbd) + tempb0*A_symd[4] + A_sym[4
        ]*tempb0d - 2*A_sym[3]*tempbd;
    A_symb[3] = A_symb[3] + A_sym[5]*tempb1 - 2*A_sym[3]*(*detb) + A_sym[4]*
        tempb0 - 2*A_sym[3]*tempb;
}

/*
  Differentiation of MatDetAM1Symmetric_t_nodiff in forward (tangent) mode:
   variations   of useful results: *det
   with respect to varying inputs: A_sym[0:6-1]
   Plus diff mem management of: det:in A_sym:in
*/
static inline void MatDetAM1Symmetric_t_nodiff_d(const double A_sym[6], const double A_symd[6]
        , double *det, double *detd) {
    double temp;
    double temp0;
    double temp1;
    temp = A_sym[1]*A_sym[2] - A_sym[3]*A_sym[3];
    temp0 = A_sym[3]*A_sym[4] - A_sym[5]*A_sym[2];
    temp1 = A_sym[5]*A_sym[3] - A_sym[4]*A_sym[1];
    *detd = (temp+A_sym[1]+A_sym[2]+1.0)*A_symd[0] + A_sym[0]*(A_sym[2]*A_symd
        [1]+A_sym[1]*A_symd[2]-2*A_sym[3]*A_symd[3]) + (temp0-2*A_sym[5])*
        A_symd[5] + A_sym[5]*(A_sym[4]*A_symd[3]+A_sym[3]*A_symd[4]-A_sym[2]*
        A_symd[5]-A_sym[5]*A_symd[2]) + (temp1-2*A_sym[4])*A_symd[4] + A_sym[4
        ]*(A_sym[3]*A_symd[5]+A_sym[5]*A_symd[3]-A_sym[1]*A_symd[4]-A_sym[4]*
        A_symd[1]) + (A_sym[0]+A_sym[2]+1.0)*A_symd[1] + (A_sym[0]+A_sym[1]+
        1.0)*A_symd[2] - 2*A_sym[3]*A_symd[3];
    *det = A_sym[0]*temp + A_sym[5]*temp0 + A_sym[4]*temp1 + A_sym[0] + A_sym[
        1] + A_sym[2] + A_sym[0]*A_sym[1] + A_sym[0]*A_sym[2] + A_sym[1]*A_sym
        [2] - A_sym[5]*A_sym[5] - A_sym[4]*A_sym[4] - A_sym[3]*A_sym[3];
}

/*
  Differentiation of MatTraceSymmetric_t_b in forward (tangent) mode:
   variations   of useful results: A_symb[0:6-1]
   with respect to varying inputs: *traceb A_symb[0:6-1]
   Plus diff mem management of: traceb:in A_symb:in


  Differentiation of MatTraceSymmetric_t in reverse (adjoint) mode:
   gradient     of useful results: A_sym[0:6-1] *trace
   with respect to varying inputs: A_sym[0:6-1]
   Plus diff mem management of: A_sym:in trace:in
*/
static inline void MatTraceSymmetric_t_b_d(const double A_sym[6], double A_symb[6], double
        A_symbd[6], double *trace, double *traceb, double *tracebd) {
    A_symbd[0] = A_symbd[0] + *tracebd;
    A_symb[0] = A_symb[0] + *traceb;
    A_symbd[1] = A_symbd[1] + *tracebd;
    A_symb[1] = A_symb[1] + *traceb;
    A_symbd[2] = A_symbd[2] + *tracebd;
    A_symb[2] = A_symb[2] + *traceb;
}

/*
  Differentiation of MatTraceSymmetric_t_nodiff in forward (tangent) mode:
   variations   of useful results: *trace
   with respect to varying inputs: A_sym[0:6-1]
   Plus diff mem management of: A_sym:in trace:in
*/
static inline void MatTraceSymmetric_t_nodiff_d(const double A_sym[6], const double A_symd[6],
        double *trace, double *traced) {
    *traced = A_symd[0] + A_symd[1] + A_symd[2];
    *trace = A_sym[0] + A_sym[1] + A_sym[2];
}

/*
  Differentiation of tau_symmetric in forward (tangent) mode:
   variations   of useful results: *energyb tau_sym[0:6-1] e_symb[0:6-1]
                *mub *lambdab
   with respect to varying inputs: *energyb tau_sym[0:6-1] e_sym[0:6-1]
                lambda e_symb[0:6-1] *mub mu *lambdab
   RW status of diff variables: energyb:(loc) *energyb:in-out
                tau_sym:(loc) tau_sym[0:6-1]:in-out e_sym:(loc)
                e_sym[0:6-1]:in lambda:in e_symb:(loc) e_symb[0:6-1]:in-out
                mub:(loc) *mub:in-out mu:in lambdab:(loc) *lambdab:in-out
   Plus diff mem management of: energyb:in tau_sym:in e_sym:in
                e_symb:in mub:in lambdab:in
*/
static inline void tau_symmetric_d(double e_sym[6], double e_symd[6], double tau_sym[6],
        double tau_symd[6], const double lambda, const double lambdad, double
        *lambdab, double *lambdabd, const double mu, const double mud, double
        *mub, double *mubd, double *energyb, double *energybd) {
    double e2_sym[6];
    double e2_symd[6];
    double e2_symb[6];
    double e2_symbd[6];
    double fabs0;
    double result1;
    double result1d;
    double temp;
    int ii1;
    double temp0;
    double temp1;
    int ii2;
    for (ii1 = 0; ii1 < 6; ++ii1)
        e2_symd[ii1] = 0.0;
    for (int i = 0; i < 6; ++i) {
        e2_symd[i] = 2*e_symd[i];
        e2_sym[i] = 2*e_sym[i];
    }
    double detbm1;
    double detbm1d;
    double detbm1b;
    double detbm1bd;
    MatDetAM1Symmetric_t_nodiff_d(e2_sym, e2_symd, &detbm1, &detbm1d);
    double J;
    double Jd;
    double Jb;
    double Jbd;
    double TOL = 1E-8;
    temp = sqrt(detbm1 + 1);
    Jd = (fabs(detbm1 + 1) < TOL ? 0.0 : detbm1d/(2.0*temp));
    J = temp;
    double logJ = log(detbm1+1)/2.;
    double logJd = detbm1d/(2.*(detbm1+1));
    double logJb = 0.0;
    double logJbd;
    double trace_e;
    double trace_ed;
    double trace_eb;
    double trace_ebd;
    MatTraceSymmetric_t_nodiff_d(e_sym, e_symd, &trace_e, &trace_ed);
    temp = (J*J-1)/4 - logJ/2;
    *lambdabd = *lambdabd + (*energyb)*(2*J*Jd/4-logJd/2) + temp*(*energybd);
    *lambdab = *lambdab + temp*(*energyb);
    Jbd = 2*(lambda*(*energyb)*Jd/4+J*((*energyb)*lambdad+lambda*(*energybd))/
        4);
    Jb = 2*J*lambda*(*energyb)/4;
    temp = lambda/2 + mu;
    logJbd = -((*energyb)*(lambdad/2+mud)+temp*(*energybd));
    logJb = -(temp*(*energyb));
    *mubd = *mubd + (*energyb)*(trace_ed-logJd) + (trace_e-logJ)*(*energybd);
    *mub = *mub + (trace_e-logJ)*(*energyb);
    trace_ebd = (*energyb)*mud + mu*(*energybd);
    trace_eb = mu*(*energyb);
    *energybd = 0.0;
    *energyb = 0.0;
    double e_symb[6] = {0.};
    double e_symbd[6] = {0.0};
    for (ii1 = 0; ii1 < 6; ++ii1)
        e_symbd[ii1] = 0.0;
    MatTraceSymmetric_t_b_d(e_sym, e_symb, e_symbd, &trace_e, &trace_eb, &
                          trace_ebd);
    if (detbm1 + 1 >= 0.0)
        fabs0 = detbm1 + 1;
    else
        fabs0 = -(detbm1+1);
    temp = sqrt(detbm1 + 1);
    result1d = (fabs(detbm1 + 1) < TOL ? 0.0 : detbm1d/(2.0*temp));
    result1 = temp;
    temp = logJb/(2.*(detbm1+1));
    temp0 = logJb/(2.*(detbm1+1));
    temp1 = Jb/(2.0*result1);
    detbm1bd = (fabs0 < TOL ? (logJbd-temp*2.*detbm1d)/(2.*(detbm1+1)) : (
        logJbd-temp0*2.*detbm1d)/(2.*(detbm1+1)) + (Jbd-temp1*2.0*result1d)/(
        2.0*result1));
    detbm1b = (fabs0 < TOL ? temp : temp0 + temp1);
    for (ii1 = 0; ii1 < 6; ++ii1)
        e2_symbd[ii1] = 0.0;
    MatDetAM1Symmetric_t_b_d(e2_sym, e2_symd, e2_symb, e2_symbd, &detbm1, &
                           detbm1b, &detbm1bd);
    for (int i = 5; i > -1; --i) {
        e_symbd[i] = e_symbd[i] + 2*e2_symbd[i];
        e_symb[i] = e_symb[i] + 2*e2_symb[i];
        e2_symbd[i] = 0.0;
        e2_symb[i] = 0.0;
    }
    for (int i = 3; i < 6; ++i) {
        e_symbd[i] = e_symbd[i]/2.;
        e_symb[i] /= 2.;
    }
    // b = 2 e + I
    double b_sym[6];
    double b_symd[6];
    for (ii1 = 0; ii1 < 6; ++ii1)
        b_symd[ii1] = 0.0;
    for (int j = 0; j < 6; ++j) {
        b_symd[j] = 2*e_symd[j];
        b_sym[j] = 2*e_sym[j] + (j < 3);
    }
    // tau = (dPsi / de) b
    double dPsi[3][3], b[3][3], tau[3][3];
    double dPsid[3][3], bd[3][3], taud[3][3];
    for (ii1 = 0; ii1 < 3; ++ii1)
        for (ii2 = 0; ii2 < 3; ++ii2)
            dPsid[ii1][ii2] = 0.0;
    SymmetricMatUnpack_d(e_symb, e_symbd, dPsi, dPsid);
    for (ii1 = 0; ii1 < 3; ++ii1)
        for (ii2 = 0; ii2 < 3; ++ii2)
            bd[ii1][ii2] = 0.0;
    SymmetricMatUnpack_d(b_sym, b_symd, b, bd);
    for (ii1 = 0; ii1 < 3; ++ii1)
        for (ii2 = 0; ii2 < 3; ++ii2)
            taud[ii1][ii2] = 0.0;
    MatMatMult_d(1., dPsi, dPsid, b, bd, tau, taud);
    SymmetricMatPack_d(tau, taud, tau_sym, tau_symd);
}

#endif // TAPENADE_H
